
20th december - 20th jan


java is beoming very essential knowledge

  
 what is java?
 
   java is object oriented programming language
   we have different programming languages are there 
   
     1.procedure oriented 
	 2.object oriented 
	 3.scripting oriented
	 4.modula oriented
	 
	 
python
.net
php....
   
   
  java got released in the year of 1995 

  almost 27 years completed

  still it is maintaining it's popularity 

  how it is possible?

   answer: because of java is maintaining unique features
   /charactersitics/buzzwords
   
   1.simple
   2.platform indepenedent
   3.architectural neutral
   4.portable
   5.object oriented
   6.robust
   7.interpreted
   8.high performance
   9.secured
   10.distributed
   11.dynamic
   12.mulithreaded
   
   

java developer
.net developer
php developer 
   
   
   goal ->to develop software/application
   
 what type of applications we have in the market?

 ->desktop applications
 ->distributed applications
 
   
  desktop application/standalone application:

it is an application in which machine
we instlled in that machine only we are able 
to consume the services.

the results of the desktop applications are 
not sharable


ex:
acroabatic reader,
antivirus,
mspaint,
calucator
 etc..
 link to access the notes:
 https://github.com/somanapalli/3ttech
   
 
distributed application/network based application:
````````````````````````````````````````````````````
it is also an applcation which we can able to access from any where 
make sure that machine should be connected to a proper internet.

ex: facebook, gmail, yahhoo. .. etc..
 
   
   the results of the distributed applications are sharable 
   across the globe.
   
   
why should we learn core java or significance of learning core java?


->using core java knowledge, we are able to develop standalone
  applications/desktop applications.

->using core java knowledge,we  are able to learn advaned java

->to learn high end tools like salesforce, pega,bigdata, mulesoft 
  we need core java knowledge
  
  
java got released in the year of 1995

 by jamesgosling and his team (14 members)
 
   he is the author 

from sunmicrosystem

   he releaed into three editions
   
   1.jse-java standard editions-core java
   
          we can develop standalone /desktop applications
		  
   2.jee-java enterprise editions-adv java
   
          we can develop enterprise/distributed applcations
		  using this we also can develop desktop applications
		  
		  
		  
   3.jme-java micro/mobile applications
   
         we can develop micro/mobile related applications 
		 
		   ex: android
		   
		   
if you are programmer

 -to devlop the software/application

 -we have to write the programs
 
prerequistes to write a java program?
````````````````````````````````````

c progam -> turbo c software -> 
cpp program -> turbo cpp software ->

java program -> jdk sofware 
  jdk -Java development kit
  
 1.download the jdk software
 2.install the software
 3.select the editor(notepade,notepad++,editplus,eclipse,myeclipse..)
 4.write the java program 
 5.save the java program (.java)
   note: extension always must be .java and that to 
   it must be in lower case letters.
 
 6.compile the java program 
 
 7.run/execute the java program 
 
 
 





from where we can download the jdk software?

 official website: www.oracle.com
 
 sunmicrosystem -organization 
 
 oracle purchase all copyrights of sunmicrosystem
 
 
  scjp ->sun certified  java programmer
  
  ocjp -> oracle certified java programmer
  
  
after software got installed how can we cross check whether it is 
installed suceesfuly or not?
 open command prompt 
 
 and pass the below command
 
 
 cmd:/>java -version
 
 java version "19.0.1" 2022-10-18
 Java(TM) SE Runtime Environment (build 19.0.1+10-21)
 Java HotSpot(TM) 64-Bit Server VM (build 19.0.1+10-21, mixed mode, sharing)


topics:
```````
->what is java
->list of features of java
->significance of learning core java
->types of applications
->history of java 
->download and install jdk software?
->prerequisites to write the java program
->different java editions 

   
   
structure of the java program:
````````````````````````````````

every java program should starts with by defining the class.


  class <classname>
  {
  
  
  }

ex:

  class Student
  {
  
  
  }


compile the java program:

for this open command prompt and give below command

 cmd:/> javac <filename>.java
 
 
 example:
 ``````````
 C:\Users\LENOVO>javac Demo.java
error: file not found: Demo.java
Usage: javac <options> <source files>
use --help for a list of possible options

C:\Users\LENOVO>e:

E:\>cd 3ttech

E:\3ttech>dir
 Volume in drive E is study
 Volume Serial Number is EC97-9253

 Directory of E:\3ttech

21-12-2022  10:07    <DIR>          .
21-12-2022  10:07             4,585 corejava_notes
21-12-2022  10:07                18 Demo.java
               2 File(s)          4,603 bytes
               1 Dir(s)  76,667,604,992 bytes free

E:\3ttech>javac Demo.java

E:\3ttech>


we have to execute/run the program

cmd:/> java <classname>

   note:
   every java program execution starts from main() only.
   
    public static void main(String[] args)
	{
	
	
	}
   
   
  without main() can we compile the java program?

   yes, we can compile
   
  without main() can we execute the java program?
  no, we can't because execution of the java program should always 
  starts from main() only.
  
  
  we are always write the logic inside the method(s) whether it is 
  user defined method or predefined method.
  
  
E:\3ttech>javac Demo.java

E:\3ttech>java Welcome
welcome to java sessions

E:\3ttech>

 
  
  
  
  
  
 why should we compile the java program?

 
  who will compile the java program?
  
   what is  java compiler?
   
   C:\Program Files\Java\jdk-19\bin
	
	
 where all the java tools are available like javac, java, javap, javadoc , javaw etc.

 
 when we compile the  java progarm what will happen?

 java compiler will check syntactical mistakes 

programmer follows correct syntaxes or not?

 
  if programmer follows everything syntactically it is good?
  
  java compiler will generate one .class file based on the class name
  
  .class file contains byte code, which is not human readable code.

  which can be understandable by java interpreter which is jvm 
  (java virtual machine)

  
   what will happen when we execute the java progarm?
   
   who will execute the java program?
   
     java interpretor (jvm) -> bin folder
	 
	 it will take .class file as an input and converts this byte code
	 into machine level code(binary code 0's and 1's)
	 
	 
	execute
	
	java Welcome
	
   
 q) is it possible to give both file name and class name are same?

  
   
jdk-

   it provides two environments
   
   1.developer environment -we can develop the java programs
   2.runtime environment- we can run the java applications 
   
jre
    -java runtime environment
	
    -it provides runtime environment.



jvm
   -java interpretor (jvm)
   -java virtual machine
   
  jdk = jre + jvm 
  
  
   
   zoom-> runtime environment
   
    myself -> jvm 
	
	
   COMPILATION VS EXECUTION 
   STRUCTURE OF THE JAVA PROGRAM 
   JDK VS JRE VS JVM 
   
   
   .JAVA 
      -> .CLASS FILE -> BYTE CODE
	  
	  JAVA INTERPRETOR (JVM ) - BYTE CODE -> MACHINE LEVEL CODE 
	  
 note:
java supports member variables and member methods


inside the clas if we declare variable s-> member vairables
inside the class if we define the methods:-> member methods

class names always unique
package(s)

 
JAVA IS OBJECT ORIENTED PROGRAMMING LANGUAGE
 
    ->since it follows oops principles
	
	
	inheritance
	polymoprhism
	abstraction 
	encapsulation 
	
 
 in java, to achieve the above 4 principles we are using 
 two concepts 
 
  1.class
  2.object
  
 
 
 class:
 ``````
 
 every java program should starts with 
 by defining the class.
 
 class is a collection 
 
   -variables 
   -& method(s)
   
   
 every java reserved keyowrd alwyas must be in 
 lower case.
 
 
 
 variable:
 ``````````
 
   variable is like a data container 
   
 
 definition: 
 purpose: to store the data
 syntax:
 
    <datatypename> <variablename> = <value>;
	
 
 String stname = "ramakrishna";
 int stid=100;
 double marks = 78.5;
 
    
	variable is the name which we are given to memory location .
	
	
	in java, while we are stroing any value inside an variable 
	we have to use datatype also.
	
what type of datatypes are available in java:

 majorly we do have 4 categories 



primitive datatypes.


1.integer

  -to store integer values
  
  byte
  short
  int
  long
  
  
  
  
2.charcter

   -to store single character informatin 
   
   -char
   
3.float
  -to store decimal values
  
  -float
  -double
  
  
4.boolean 

   -to store logical values either true/false.
   
   -boolean 
   
   
1.byte - 1 byte - 8 bits
2.short - 2 bytes - 16 bits
3.int - 4 bytes
4.long - 8 bytes

5.char - 2 bytes

6.float  -  4 bytes
7.double  - 8 bytes

8.boolean  - undefined by the sunmicrsosystem 




   every datatype has two things
   
   1.memory size
   2.range of the value
   
   

 byte range 
 
  byte -> 1 byte -> 8 bits 
  
  we have one formula 
  
  -2^n-1 to (2^n-1) - 1
  
  -2^7 to 2^7 - 1
  
  -128 to 127
  
    range of the byte datatype
	

 130
 
 byte b  = 130;
 
 
 short -> 2 bytes -> 16 bits
 
 -2^15 to 2^15 -1 
 
to store character data, it must be enclosed with in the 
single quotation. otherwise it gives compile time error.


float 
double

by default float type data can be considered as double type.

to specifiy any decimal value as float type, after the data 
specify f letter so that it can considered as float type.

difference between float and double?

 float - 4 bytes
 double -> 8 bytes

  3.454545
  5.34535345353534535335
  
 float can take upto 7 digits as precesion size where 
 as double can take upto 15 digits as precision size.
 
 
boolean category:
```````````````````
to store logical values either true or false.

all the primitive datatypes must be in lower case only.

  boolean b = True;
  
  true and false are the java reserved keywords 
  all the java reserved keywords must be in lower case .
  
 
example:
`````````
class Demo
{
	
	public static void main(String[] args)
	{
	
	  byte b = 127;
	  char c = 'a';
	  float f = 5.67656757656567576f;
	  double d = 5.6767757575775646456;
	  
	  boolean e = false;
	  
	  int st$id2=100;
	  
	  
	  
	  System.out.println(b);
	  System.out.println(c);
	  System.out.println(f);
	  System.out.println(d);
	  System.out.println(e);
	  
	  System.out.println(st$id2);
	}

}
	


 rules to declare the variable name:
 ````````````````````````````````````
 

1.variable name should always starts with alphabet 
  it should not start with numeric 

2.no special characters are allowed except $ and _(underscore)  

3.we are not allowed to use varaible names as java reserved words.

  
  

4.variable names are case sensitive.

5.blank spaces are not allowed while we are declaring the variables. 
 
  
examples:
`````````
    //invalid : int 5stid=100;
	//valid : int st$id=100;
	//valid: int st_id=100;
	//invalid: int st*id=100
	
	//invalid : int int = 100;
	//invalid: int st id=100;
	
 
 
 method:
 method is the place where we are writing the logic to perfrom 
 some operation based on the requirement?
 syntax
  
  <returntype> <methodname>()
  {
  //logic
  }
  
  
q:
define the method which accepts two integer parameters and returns their sum?


              int getSum(int x, int y)
			  {
			    returns x+y;
			  }
 
 
 
q:
define the method which accepts one integer parameter and String paramteer and display their values?


                      void getDetails(int x, String y)
					  {
					    System.out.println(x);
						System.out.println(y);
					  }
 
 q:
define the method which accepts student information like 
student id, studentname and student marks and display their 
details?


             void getStudentDetails(int stid, String stname,double stmarks)
			 {
			    System.out.println("student id: " + stid);
				System.out.println("student name:" + stname);
				System.out.println("student marks: " + stmarks);
				
			 }


q:
define the method which accepts first name and last name and returns their full name?


              String getFullName(String firstName,String lastName)
			  {
			  return firstName+lastName;
			  }


q:
define the method which accepts radious as input parameter 
and returns area of the circle?

                area of the circle formular 
				A = PI * r * r
				
				
		            double getCircleArea(double radious)
                    {
                      return 3.14*radious*radious;
                    }					  

q:
define the method which accepts student marks subject wise and return their total marks?
   
             telugu,hindhi,english

			  
			  double getTotalMarks(double telugu,double hindhi,double english)
			  {
			    return telugu+hindhi+english;
			  }
			  
			  
q:
define the method which accepts currency as input parameter and returns productname such as soap?

                      String getProduct(double currency)
					  {
					    return "santoor";
					  }
     
 single character
 String -group of character
 
	

class is a collection of 

   -variables
   -& methods


example:
``````````
class Student
{

  //variables
  
 static int stid =100;
 static String stname="rama";
  
  //methods
  public static void displayDetails()
  {
	   System.out.println("student id: " + stid);
	   System.out.println("student name: " + stname);
  }

   public static void main(String[] args)
   {
	   //call the methods
	   displayDetails();
   }

}

   java is object oriented programming language
   
    -since it follows oops principles
	
	  inheritance
	  polymoprhism
	  abstraction
	  encapsulation
	  
	  to achieve above principles in java, we are using 
	  two concepts
	  
	  1.class
	  2.object
	  
class:
 class is a collection of vairables
 and methods into a single unit. 
 
object:
``````

object is an instance of a class. 

 whenever we define the class, memory spaces 
 will not be created for the properties of the class.
  
 instance:
 allocating sufficient amount of memory space for the instance 
 proeprties of the class.
 
 
syntax for object creation:
```````````````````````````
<classname> <objectname> = new <classname>();


Student obj = new Student();

  Student -> name of the class
  obj -> name of the object
   = -> assignment operator 
   
   new -> dynamic memory allocation operator
   Student() -> constructor
   
   
example:
`````````
class Student
{

  //variables
  
 int stid =100;
  String stname="rama";
  
  //methods
  public void displayDetails()
  {
	  System.out.println("===================");
	   System.out.println("student id: " + stid);
	   System.out.println("student name: " + stname);
  }

   public static void main(String[] args)
   {
	   //create the object for Student class
	   
	   Student obj  = new Student();
	   
	   System.out.println(obj.stid);
	   System.out.println(obj.stname);
	   
	   //call the method
	   
	   obj.displayDetails();
	   
	   
   }

}


for a single class how many object(S) we can create?

 ansewr:
 as many as we want based on the requirement
 
 Student obj1 = new Student();
 Student obj2 = new Student();
 
 objct name is always unique.
 
 
why we need to create multiple objects for a single class?

college

  1000 students
  
     to store 1000 students information /data
	 how many objects are required?
	 
	   every object is having a specific student information 
	   
	   1000 objects
	   
<classname> <objectname> = new <classname>();


using object name, we are able to access the 
variables and as well as methods.

using object, how can we update the values?

example:
`````````
class Student
{

  //variables
  
 int stid =100;
  String stname="rama";
  
  //methods
  public void displayDetails()
  {
	  System.out.println("===================");
	   System.out.println("student id: " + stid);
	   System.out.println("student name: " + stname);
  }

   public static void main(String[] args)
   {
	   //create the object for Student class
	   
	   Student obj  = new Student();
	   
	   //updating the values using object name
	   obj.stid=101;
	   obj.stname="sridevi";
	   
	   //call the methods
	   obj.displayDetails();
   
   }
}





example:
`````````
class Student
{

  //variables
  
 int stid =100;
  String stname="rama";
  
  //methods
  public void displayDetails()
  {
	  System.out.println("===================");
	   System.out.println("student id: " + stid);
	   System.out.println("student name: " + stname);
  }

   public static void main(String[] args)
   {
	   //create the object for Student class
	   
	   Student obj1  = new Student();
	   
	   Student obj2 = new Student();
	   Student obj3 = new Student();
	   
	   System.out.println(obj1);
	   System.out.println(obj2);
	   System.out.println(obj3);
    
   }

}

note:
every new object is having a specific new address

non static (instance) vs static:
```````````````````````````````````
 int a;//non static variable or instance variable
 
 static int a;//static variable
 
 how can we make non static proeprty as static 
 property?
 
   by using one java reserved keyword 'static'.
   
   //non static or instance method 
  void m1()
  {
   //logic
  }
  
  //static method 
  static void m2()
  {
  //static area
    //logic
  }
  

the area which belongs to non static method is known as 
instance area or non-static area

the area which belongs to static method is known as 
static area .


note:
from the static area, if we want to access
nonstatic properties we can access using 
object name.

from the static area and non-static area,  if we want to access  
static properties we can access in following ways

1.we can access directly 
2.we can access using classname 
3.we can access using object name (not recommended)



when can you make a normal proeprty as 
static property?

 if a property is common to multiple objects
 
 once we declare any property as static , 
 memory wil be created only once at the time 
 class loading 
 
 
example:
``````
class Student
{

  //instance variables
  
 int stid =100;
  String stname="rama";
  static String collegeName="jntu";
  
  
  //instance methods
  public void displayDetails()
  {
	  //instance area 
	   System.out.println("===================");
	   System.out.println("student id: " + stid);
	   System.out.println("student name: " + stname);
	   System.out.println("college name: " + collegeName);
	   System.out.println("collegeName:" + Student.collegeName);
  }

//static method 
   public static void main(String[] args)
   {
	   //static area 
	   //create the object for Student class
	   
	   Student obj1  = new Student();
	   
	   System.out.println(obj1.stid);
	   System.out.println(obj1.stname);
	   //call the non static method 
	   
	   obj1.displayDetails();
	   
	   //accessing static property from the static area
	   
	   System.out.println(collegeName);
	   System.out.println(Student.collegeName);
	  
	   
   }

}


do one program 
on top of instane vs static?

  

constructor:
```````````
 constructor is a special member method 
 
 1.it must be similar to the class name 
 
 purpose: to initilize the object.
 

ide(integrated development environment)

-eclipse, myeclipse, netbeans, intellij, etc.. 

official website to download eclipse ide:

https://www.eclipse.org/downloads/packages/release/kepler/sr1/eclipse-ide-java-developers




constructor:

 purpose: to initialize the object 
 
 object contains data
 
 to initialize the data.
 
 
int a ;//variable declaration 

a=100;//assigning the value 

int a = 100;//variable initilization 




without constructors:
````````````````````````

public class Test1 {
	
	int a,b;
	
	public void setValues()
	{
		a=100;
		b=200;
	}
	public void display()
	{
		System.out.println(a);
		System.out.println(b);
	}

	
	public static void main(String[] args)
	{
		//create the object
		Test1 obj = new Test1();
		
		//call the setValues()
		
		obj.setValues();
		//call the methods
		
		obj.display();
		
	}
}

in case of normal methods, explictly we have to call those 
otherwise we will not get desired values.

1.constructor is a special member method 
2.it must be similar to class name.
3.constructor should not return any thing even void also. 
4.constructor should not be static
5.constructor should not be inherited.


in case of constructor, explictly we no need to call 
the constructor 

when constructor will be invoked?
whenever we create the object 

how many no.of times constructor will be invoked?
answer:
  how many no.of times you create the object, those many no.of times
  corresponding constrcutor will be invoked.
  
  
example:
`````````

public class Test1 {
	
	int a,b;
	
	//constructor
	public Test1()
	{
	  a=100;
	  b=200;
	}
	
	public void display()
	{
		System.out.println(a);
		System.out.println(b);
	}

	
	public static void main(String[] args)
	{
		//create the object
		Test1 obj = new Test1();
		//call the diplay method 
		obj.display();
		
	}
}

types of constructor:
``````````````````````
1.default constructor 

  ->constructor whihc doesn't takes any parameters 
  
  again this is of two types 
  
   1.user defined default constructor 
       ->this is for initializing our own values
   2.system defined default constructor 
       ->this is for initializing default values based on the datatype.
	   
	   
2.parameterized constructor:

   ->constructor which takes parameters 
   
   

note:
in case of default constructor first default values 
will be initlized later those values will be replaced with our 
own values.

note:
in case of parameterized constructor, directly our own values will 
be initlized while you creating the object. 

q:
can we define both default and parmaterized cosntructor 
in a class?
example on parameterized constructor:


public class Test1 {

	//class level variables 
	int a, b;
  
	
	//parameterized constructor
	public Test1(int x, int y)
	{
		a=x;
		b=y;
	}
	

	public void display() {
		System.out.println(a);
		System.out.println(b);
	}

	public static void main(String[] args) {
		// create the object
		Test1 obj = new Test1(100,200);
		// call the diplay method
		obj.display();

	}
}


example on both default and parameterized constructor:
```````````````````````````````````````````````````````

public class Test1 {

	//class level variables 
	int a, b;
  
	//default constructor 
	public Test1()
	{
		a=1000;
		b=2000;
	}
	//parameterized constructor
	public Test1(int x, int y)
	{
		a=x;
		b=y;
	}
	

	public void display() {
		System.out.println(a);
		System.out.println(b);
	}

	public static void main(String[] args) {
		// create the object
		Test1 obj = new Test1(100,200);
		// call the diplay method
		obj.display();
		
		//create the object using default constructor
		 Test1 obj1 = new Test1();
		 obj1.display();
	
	}
}

this keyword in java:
``````````````````````
'this' is the java reserved keyword using for two 
purposes.

1.whenever class level variables and method level 
parameters are same 
to differentiate those we will use this keyword

example:
```````

public class Test1 {

	//class level variables 
	int a, b;
	//parameterized constructor
	public Test1(int a, int b)
	{
		this.a=a;
		this.b=b;
	}
	

	public void display() {
		System.out.println(this.a);
		System.out.println(this.b);
	}

	public static void main(String[] args) {
		// create the object
		Test1 obj = new Test1(100,200);
		// call the diplay method
		obj.display();

	}
}


2.even though we have multiple constructors are there in our application to execute all those constructors by creating 
single object it is possible 

  ->constructor chaining 
  
  syntax:
     
	  this() -> it is for caling current class default constructor 
	  
	  this(..) -> it is for calling current class parameterized constructor 
	  
	  
example:
`````````

public class Test1 {

	
	//parameterized constructor
	public Test1(int a, int b)
	{
		
		System.out.println("parameterized constructor");
	}
	
	//default constructor
	public Test1()
	{
		//call the parameterized constructor
		this(100,200);
		System.out.println("default constructor");
	}
	

	

	public static void main(String[] args) {
		// create the object
		Test1 obj = new Test1();
		
	}
}


note:
constructor call must be the first statement inside a constructor 
otherwise we will get compile time error. 


 ->eclipse ide
 ->constructor 
 ->types of constructor 
 ->this keyword
 
oops principles:
````````````````
 ->inheritance
 ->polymoprhism
 ->abstraction 
 ->encapsulation 
 
 
inheritance:
```````````
inheritane is the process of taking the properties from one class 
to another class 



class 
 i have some logic is there
 
 the same logic i wanted to use in anotehr class.
 
 if we redefine code duplication will be increased
 
 memory consumption also gets increased
 
 performamnce of the application will be degraded
 
 

instead of redefining the logic, try to reuse it



parent class/base class/super class:

it is the class which is giving the properties

child class/sub class/derived class:
it is the class  which is taking the properties


using extends keyword we can achieve the concept of inheritance.


note:
whenever we applied the concept of inheritance, it is highly 
recommended to create the object for child class not for parent class

if we create the object for parent class, memory locations will be created only for parent class.
so that , with the parent class object we are allowed to access only 
parent class properties

whenever we crete the object for child class, memory locations will 
be created for both parent and child class properties. 

so with this child class object, we are allowed to access 
both parent and child class proeprties.

what is the primary advanatage of inheritance:

 1.reusability 
 2.code redundancy will be decreased 
 3.performance of the application will be improved.
 
 
types of inheritances:
`````````````````````
in java, we have 5 types of inheritances

1.single /simple inheritance
2.multilevel inheritance
3.multiple inheritance
4.hierarchical inheritance
5.hybrid inheritance

single / simple inheritace:

  it is the inheritance which contains
     -single base class
	 -single child class
	 
	A
	|
	B

multilevel inheritance:

it contains 

  single base clas 
  
  multiple intermediate base classes 
  
  single child class 
  
  
  A
  |
  B
  |
  C

in one context, B class is acting as sub class or child class 

but in anotehr context, same B class is acting as super class or 
parent class. 

such kind of classes are known as intermediate parent classe(s).


	class A{} class B extends A{} class C extends B{}		  
 
 
 
multiple inheritance:
`````````````````````
 
   mutliple inhertiance contains 
   
   1.1 or more parent classes
   2.single child class 
   
   
       A B C D ....
	   
	       Z
 
 class Z extends A,B,C,D,...
 {
 }
 in java, through classes multiple inheritance is not possible 
 
 why?
 
 class A{
    sum()
 }
 class B {sum();}
 
 z obj = new z();
 obj.sum();
 
 
 Interface concept -> multiple inheritance.
 
 
hierarchical inheritance:

   single parent class/base
   
   mutliple child classe(s)
   
    A
	
B  C  D E ....

class A
{
}
class B extends A
{}
class C extends A{}
class D extends A{}
....


hybrid inheritance:
````````````````````
it is the combination of any two possible inheritance 
types.


 A
 |
 B
 |
C  D  E
  
 SINGLE + HIERARCHICAL = HYBRID INHERITANCE 
 
 
 class A{}
 class B extends A{}
 class C extends B{}
 class D extends B{}
 class E extends B{}
 
 
assignments:
do one one program on top of each and every 
inheritance type.


 note:
 when you apply inheitance concept, it is 
 highly recommende to create the object for 
 child class. 
 
 
A.java:
```````
//parent class cum business logic class
public class A {
	public A()
	{
		System.out.println(this.hashCode());
	}
	public void sum(int x, int y)
	{
		System.out.println("sum is : " +  (x+y));
	}

}

B.java
````````
//child class cum business logic class cum executin logic class
public class B extends A {
	
	public void sub(int x, int y)
	{
		System.out.println("substraction: " +(x-y));
	}
	
	public static void main(String[] args) {
		
		//child class object creation 
		
		B obj = new B();
		
		obj.sum(2, 3);
		obj.sub(5, 4);
		
	}

}



polymoprhism:
````````````
it is one of the oop principle.

definition: 

 poly -> many 
 morphs -> forms.
 
 so polymoprhism means many forms.
 in java, we have two types of polymorphisms
 are there.
 
   1.compile time polymoprhism ->method overloading
   2.runtime polymorphism-method overriding
   
   
 method overloading:
```````````````````````
 it is the process of definining 
 the method name as same by changing
 signature as different.

  signature changing
  -> type of parmaeters 
  -> no.of parameters
  -> order of parameters

  
 example of method overloading:
`````````````````````````````

public class Test2 {

	
	public void sum(int x, int y)
	{
		System.out.println("integer sum is: " +(x+y));
	}
	
	//type of parameters changed
	public void sum(double x, double y)
	{
		System.out.println("double sum is : " + (x+y));
	}
	//changed no.of parameters
	public void sum(int x, int y, int z)
	{
	System.out.println("3 integer sum is : " +(x+y+z));	
	}
	
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		// call the sum()
	    obj.sum(10,20);
	    
	    //call the sum(double x, doubl y)
	    obj.sum(10.3,45.6);
	    
	    //call the sum(int x , int y, int z)
	    
	    obj.sum(10,20,30);
	    
		
	}
	
}

 
   






advnatage of method overloading:
```````````````````````````````
 how method overloading we can consider as the example of 
 
 compile time polymorphism.
 
 
advantages:
````````````
Method overloading increases the readability of the program. 

This provides flexibility to programmers so that they can call the same method for different types of data. 

This makes the code look clean. 

This reduces the execution time because the binding is done in compilation time itself.



binding:

  obj.sum(10,20);
  
    control will go to sum(int , int) 
	  this method calling and binding this associatin will happen 
	  at compile time using reference variable only.
	  
	->compile time polymoprhism

note:
when the method binding happens at compiletime using reference variable 
this kind of polymoprhism is called as compile time polymorphism 


 in the concept of method overloading .
 
 
method overriding:
``````````````````
 method overridng is the process of 
  defining method name as same and body/logic is different 
  from one class to anotehr class. 
  
  
note:
to perform method overriding, we require minimum two classes with 
parent child relation .



A.java:
```````
//parent class cum business logic class
public class A {
	
	public void sum(int x, int y)
	{
		System.out.println("sum is : " +  (x+y));
	}

}

B.java:
````````
//child class cum business logic class cum executin logic class
public class B extends A {
	
	@Override
	public void sum(int x, int y)
	{
		System.out.println("substraction: " +(x-y));
	}
	
	public static void main(String[] args) {
		
		B obj = new B();
		obj.sum(4, 3);
		
	}

}
 
 
note:
`````
The @Override annotation indicates that the child class method is over-writing its base class method. 

It extracts a warning from the compiler if the annotated method doesn't actually override anything. 

It can improve the readability of the source code.

 
 
 method overriding -> runtime polymoprhism
 
in case of runtime polymoprhism , method binding will happen at
runtime based on the object type not based on the reference variable.

example:
````````
A.java:
```````
//parent class cum business logic class
public class A {
	
	public void sum(int x, int y)
	{
		System.out.println("sum is : " +  (x+y));
	}

}

B.java:
```````
//child class cum business logic class cum executin logic class
public class B extends A {
	
	@Override
	public void sum(int x, int y)
	{
		System.out.println("substraction: " +(x-y));
	}
	
	public static void main(String[] args) {
		
		/*B obj = new B();
		obj.sum(4, 3);*/
		/*A obj = new A();
		obj.sum(2, 3);*/
		
		//runtime polymorphism
		A obj = new B();
		obj.sum(4, 3);
		
		
	}

}

rules to perform method overriding:
`````````````````````````````````````
The access modifier can only allow more access for the overridden method.

A final method does not support method overriding.

A static method cannot be overridden.

Private methods cannot be overridden.

The return type of the overriding method must be the same.



 polymorphism
   compile time polymoprhism - method overloading 
   
   runtime polymoprhism - method overridng 
   
   @Override 
   
   rules to perfrom mehtod overriding 
   
encapsulation:
``````````````
encapsulation is the process of wrapping up of datamembers and 
member functions into a single unit. 

ex: class is the best example for encapusulation .


advantage:
`````````
 data hiding.
 
 make those varialbes as private.
 
 
advantages of encapsulation:

Encapsulation is a way to restrict the direct access to some components of an object, so users cannot access state values for all of the variables of a particular object. 


Encapsulation can be used to hide both data members and data functions or methods associated with an instantiated class or object.


how can we make normal class as java encapsulated class:
````````````````````````````````````````````````````````

1.declare variables as private .
2.for each and every varaible maintain public settter and getter      methods to set and get the data. 



Student.java:
````````````

//encapsulated class
public class Student {
	
	
	 private int stid;
	 private String stname;
	 
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
 

}


Test3.java:
``````````````

public class Test3 {

	public static void main(String[] args) {
		
		Student obj = new Student();
		
		obj.setStid(100);
		 
		System.out.println("student id is: " + obj.getStid());
		
		obj.setStname("rama");
		
		System.out.println("student name is: " + obj.getStname());
	}
}

note:
``````
in the process of encapsulation, we have more control on top of the 
program since we have public setters and getter methods are there using these methods we can control the data. 

encapsulation is indirectly helping to achieve the concept of 
abstraction .


command line arguments:
`````````````````````````
java execution starts from main method 

main method will be called by jvm automatically whenever you execute 
the java program .

main method is taking array of String as an argument 


for every primitive datatype we do have corresponding wrapper classes 
are there inside java.lang package.

  byte  --> Byte  ->parseByte(String) and returns corresponding datatype
  it is returning byte as the returntype 
  
  short --> Short ->parseShort(String) -> short
  int   --> Integer 
  long  --> Long 
  
  char -> Character 
  boolean -> Boolean 
  
  float -> Float
  double -> Double 
  
  ctrl + shift + t
  
  
 note:
 whatever the arguments we are passing while we are executing the program , those arguments we call it as command line arguments.
 
 why main() method is taking String as an argument?
 
  answer: to handle command line arguments.
  
Test4.java:
``````````

public class Test4 {
	
	public static void main(String[] args) {
		
		String s1 = args[0];
		String s2 = args[1];
		//converting first String argument into integer value
		int x = Integer.parseInt(s1);
		
		//converting second String argument into integer value
		
		int y =  Integer.parseInt(s2);
		
		int z = x+y;
		System.out.println("sum is : " +z);
	}

}

why we are calling these classes as the wrapper classes:

    The wrapper class in Java provides the mechanism to convert primitive into object and object into primitive
	
	Integer 
	
	   parseInt(String)
   
        int -> primitive type (object to primitive)
		
		it is also converting primitive type to object type 
		
		
		using toString(int)->String 
		
		
abstraction:
``````````````
abstraction is one of the oop principle, it is the process of 
retrieving the essential/required details by ignoring implementation details.

  send one message from your mobile number to your friend mobile number.
  
  whether the message is deliverd or not?
  
  
   if you drive a car, if you press on accelearator, 
   your focus is whether it increases the car speed or not?
   
   
 abstraction is internally hiding the internal 
 implementation details.


 in java, we have two classes are there
 
  1.concrete class:
 it is a class, which contains only defined methods.

  defined method: 
   it is a method which contains method heading and method body 

   
  
  2.abstract class
  
  
  it is a class, which contains both defined and undefined methods
  note: 
  it is highly recommended to have atleast one undefined method .
  
  
  undefined method/abstract method:
  
  undfined method is the one which contains only method heading 
  
  //defined method 
    public void m1()
	{
	  //logic 
	}
 
  public abstract void m1();

note:

using abstract keyword we are making normal methods as 
abstract methods then only java compiler can recognize your method 
as abstract method.


abstract class Student
{
  public void m1()
  {
    //logic 
  }
  public abstract void m2();
}

 Student obj = new Student();
 
 obj.m1();
 
 obj.m2();

note:
for abstract class, can we create the object or not?

 answer: no , we can't create or we can not instantiate the abstract class.
 
 
example:
``````

abstract class Test1
{
   abstract void m1();
   abstract void m2();
}

note:
if a method is common to multiple classes then it is highly recommended
to declare that method as an abstract method instead of defined method.

   abstract class Bank{
   public abstract double rateOfInterest();
   }

//implementation class for Bank abstract class
class Icici extends Bank
{

  public double rateOfInterest()
  {
    return 6.5;
  }
}

//implementation class for Bank abstract class 

class CityBank extends Bank
{
   public double rateOfInterest()
{
   return 5.5;
}   
   
}

//runtime polymorphism
 Bank obj = new Icici();
 obj.rateOfInterest():
 
 Bank obj1 = new CityBank();
 
 obj1.rateOfInterest();
 
 
example:
`````````
Test5.java:
````````````


public abstract class Test5 {
	
	//undefined method or abstract method
	public abstract void sum(int x, int y);
	
	public abstract void mul(int x, int y);
	
	//defined method
	public void sub(int x, int y)
	{
		System.out.println("substraction is: " +(x-y));
	}

}


Test6.java:
``````````

public  class Test6 extends Test5 {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is : " + (x+y));

	}

	@Override
	public void mul(int x, int y) {
		System.out.println("multiplication is: " +(x*y));
		
	}
	
	public static void main(String[] args) {
		
		//runtime polymorphsim 
		Test5 obj = new Test6();
		obj.sum(2, 3);
		obj.sub(5, 4);
		obj.mul(5, 4);
		
	}

}




note:
`````
whenever we inherit the abstract class, in the implementation class 
you should provide the logic for all the abstract methods if you are 
not providing the logic atleast for one abstract method that implementation class also will become as abstract class.



constructor should not be inherited.

public class Test1()
{

  public Test1()
  {
  }
}

public class Test2 extends Test1
{
    public Test2()
	{
	}
	
	public Test1()
    {
    }

}


why constructor is not inherited from parent class to child class?

if a constructor is inherited from parent class to child class, 
it is violating the constructor rule saying that constructor name 
and class name must be same.


q:

can we define the constructor inside an abstract class?

we can define the constructor and we can make it execute.


note:
for every constructor java compiler will add one reserved keyword 
i.e super() which is used to invoke parent class default constructor.

 
 this() -> to call the current class default constructor
 this(..)-> to call the current class parameterized constructor..
 
 
 super() -> to call the parent class default constructor
 super(..)-> to call the parent class parameterized cosntructor.
 
 
 
note:
to invoke the parent class default constructor writing the super() 
is optional 

eventhough if we are not adding that super() , that will be added by 
the java compiler make sure parent class should not have any other 
constructor.


note:
`````
writing the super(..) is mandatory to call parent class parameterized 
cosntructor since parameterized constructor is available in many forms 

but writing the super() is optional to call parent class default constructor since default constructor is available in only one form 
so that compiler can write that super() automatically.


Test5.java:
```````````

public abstract class Test5 {
	
	public Test5(int x)
	{
		System.out.println("parent class parameterized constructor");
	}
	

}


Test6.java:
```````````

public  class Test6 extends Test5 {

	public Test6()
	{
		//call parent class parameterized constructor
		
		super(100);
		System.out.println("child class constructor");
		
	}
	
	
	public static void main(String[] args) {
		
		//child class object creation 
		Test6 obj = new Test6();
		
		
	}

}


super is java reserved keyword which is referening parent class 
properties.



assignments:
`````````````

super at method level 
super at variable level 



abstraction 

 we can achieve in java using two concepts 
 
 
 
 
  1.abstract class
  
  2.how to call parent class constructors using super keyword.
  
 2.interface
  
  
  
final :
``````
 final is a java reserved keyword, 
 for the purpose of declaring constants .
 we can apply this final keyword on following properties
 
  1.variable
  2.methods
  3.class
  
 final variable:
 ``````````````
 once we declare any variable as final variable, we can't change the value in further 
 
 if we try to change , we will get compile time error.
 
 example:
 ````````
 
public class Test8 {
	
	public static void main(String[] args) {
		
		
		final int a =10;
		System.out.println(a);
		
		a = 20;//compile time error
	
		
	}

}



final method:
`````````````

->final methods will be inherited from parent class to child class 
but we can't override.


->final methods are not participated in the concept of method overriding.

once we define the method as final, we can't override 

if we try to override final method inside childclass, we will get 
compile time error.

example:
`````````
A.java:
```````
//parent class cum business logic class
public class A {
	
	//final method
	public final void sum(int x, int y)
	{
		System.out.println("sum is : " +  (x+y));
	}

}

B.java:
```````
//child class cum business logic class cum executin logic class
public class B extends A {
	
	//compile time error
	public void sum(int x, int y)
	{
		
	}
	
	
	public static void main(String[] args) {
		
		
	}

}

final class:
`````````````
The final class is a class that is declared with the final keyword.

 We can restrict class inheritance by making use of the final class.

 Final classes cannot be extended or inherited.

 If we try to inherit a final class, then the compiler throws an error during compilation

A.java:
````````
//parent class cum business logic class
public final class A {
	
	//final method
	public final void sum(int x, int y)
	{
		System.out.println("sum is : " +  (x+y));
	}

}

B.java:
```````
//child class cum business logic class cum executin logic class
//compile time error
public class B extends A {
	
	
	
	
	public static void main(String[] args) {
		
		
	}

}


interface:
```````````
what is interface?

 interface is a collection of 
    public static final variables and 
	public abstract methods 
	
note:
inside interface it contains only abstract methods

syntax:
```````

   <interface> <interfacename>
   {
   
      //constants(public static final variables)
	  
	  //abstract methods(public abstract)
   }


by default interfce methods are public abstract we no need to 
add these public abstract keywords explictly.

can we create the object for an interface?

no we can't instantiate the interface.

using interface, we can achieve 100% abstraction security.
using abstract class, we can achieve partial abstraction.




if you want to bring properties from class to class or interface to interface  which keyword 
we have to use?
  extends
  
if you want to bring properties from interface to class which keyword
we have to use?

  implements keyword
  
  
note:
creating the object for interface or abstract class is nothing but 
creating the objects of it's implementation classes.


Test7.java:
``````````

public interface Test7 {
	//declare the method 
    void sum(int x, int y);
}


Test8.java:
```````````

public class Test8 implements Test7 {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is : " +(x+y));
		
	}

	
}

Test9.java:
```````````

public class Test9 implements Test7 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction: "+(x-y));

	}

}

Demo.java:
````````````

public class Demo {
	
	public static void main(String[] args) {
		
		//runtime polymorphism
		Test7 obj = new Test8();
		obj.sum(6, 7);
		
		Test7 obj1 = new Test9();
		obj1.sum(5, 4);
		
		
	}

}

 
example:
```````
one class can be implemented from more than one interface also 
is the concept of multiple inheritance.

Test7.java:
````````````
public interface Test7 {
	//declare the method 
    void sum(int x, int y);
}



Test8.java:
```````````
public interface Test8 {
	
	void sub(int x, int y);

}

Test9.java:
``````````
//implementation class
public class Test9 implements Test7,Test8 {

	@Override
	public void sub(int x, int y) {
		System.out.println("substraction: " +(x-y));
		 
		
	}

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));
		
	}

	

	

}

Demo.java:
````````````


public class Demo {
	
	public static void main(String[] args) {
		
		//Test7 obj = new Test7();
		//Test8 obj1 = new Test8();
		
		Test7 obj = new Test9();
		obj.sum(2, 3);
		//obj.sub(6,5);
		
		Test8 obj1 = new Test9();
		obj1.sub(5, 4);
		//compile time error:obj1.sum(6,7);
		
		Test9 obj2 = new Test9();
		obj2.sum(3, 4);
		obj2.sub(7, 6);
		
	}

}

->final keyword
->interface 

control statements/conditional statements
``````````````````````````````````````````
java compiler executes the code from top to bottom.


The statements in the code are executed according to the order
in which they appear.



However, java provides statements that can be used to control the 
flow of the java code. such statements are called control statements


java provides three types of control statements 


1.Decision making statements
2.loop statements
3.jump statements


1.Decision making statements:
`````````````````````````````

as the name suggests, decision making statements decide which statement
to execute and when.


Decision making statements evoluate boolean expression and 
control the progrma flow depending upon the result of the condition 
provided.

There are two types of decision making statemetns in java, i.e 
   -if 
   -switch
   
   
if statement:
``````````````
this staement is used to evoluate a boolean condition.

the condition of the if statement gives a boolean value either true 
or false.

in java, there are four types of if statements 

 1.simple if statement
 2.if-else statement
 3.if-else-if ladder
 4.nested if statement 
 
 

1.simple if statement:
``````````````````````
syntax:

 if(condition)
 {
   //statemetns
 }
 
example:
````````

public class Student {

	
	public static void main(String[] args) {
		
		int x=10,y=20;
		
		if(x+y>20) {
			System.out.println("x+y is greater than 20");
		}
		
	}
}

2.if-else statement:
````````````````````
a block is a concept of in between { and }

 if
 {
 
 }

if else staement is an extension of if statement, which uses 
another block of code. i.e catch block.

The else block is executed if the condition of the if block is 
evlouated as false.


syntax:
  
     if(condition){
	   //statement1;//executes when condition is true
	   }
	 else{
	   statement2 ;//executes when condition is false.
	 }

 
example:
`````````

public class Student {

	
	public static void main(String[] args) {
		
		int x=10,y=20;
		
		
		
		if(x+y<20) {
			System.out.println("x+y is less than 20");
		}
		else
		{
			System.out.println("x+y is greater than 20");
		}
	}
}

if-else-if ladder:
`````````````````````

it contains 

 1 if block
 
 multiple else if blocks 
 
 1 else block 
 
 syntax:
 
  if(condition1)
  {
    statement1;//executes when condition 1 is true
  }
  else if(condition2)
  {
    statement2;//executes when condition2 is true
  }
  else if(condition3)
  {
    statement3;//executes when conditio3 is true
  }
  ...
  else
  {
    statement4;//executes when all the condistions are false.
  }
  
example:
`````````

public class Student {

	
	public static void main(String[] args) {
		
		String city="Agra";
		
		if(city=="Chennaih") {
			System.out.println("city is chenniah");
		}
		else if(city=="Hyderabad")
		{
			System.out.println("city is Hyderabad");
		}
		else if(city=="pune")
		{
			System.out.println("city is pune");
		}
		else
		{
			System.out.println(city);
		}
			
	}
}


nested if statement:
```````````````````
in nested if statement, the if staetment can contain a if 


syntax:


  if(condition1)
  {
    staetment1;//executes when condition1 is true
	
	 if(condition2)
	 {
	    statement2;//executes when condition2 is true
	 }
	 else
	 {
	    statement3;//executes when condition2 is false.
		
	 }
  }
  

example:
`````````

public class Student {

	
	public static void main(String[] args) {
		
		int a=10,b=20;
		if(a==10)
		{
			if(b!=20)
			{
				System.out.println("dhaaps");
			}
			else
			{
				System.out.println("ramakrishna");
			}
			
		}
	}
}




switch statement:
````````````````

switch statement executes one statement from multiple conditions. 
it is like if-else-if ladder statement.


1.there can be one or n number of case values for a switch expression.

2.the case value must be of switch expression type only.
  the case value must be literal or constant.it doesn't allow 
  variables.
  
3.the case value must be unique, in case of duplicate value it will give you compile time error.


4.java switch expression type must be of byte,short,int,long(with its 
wrapper type),enums and string.

5.each case statement can have a break statement which is optional.

syntax:
```````
 switch(expression)
 {
 
   case value1:
   //code to be executed
   break;//optional
   
   case value2:
   //code to be executed
   break;//optional 
   
   ....
   
   default:
   //code to be executed if all case values are not matched
   
 
 }


}


 
example:
````````

public class Student {

	
	public static void main(String[] args) {
		
		int number=40;
		
		switch(number)
		{
		
		//case statements
		
		case 10:System.out.println("10");
		break;
		case 20:System.out.println("20");
		break;
		case 30:System.out.println("30");
		break;
		default:System.out.println("not in 10,20 or 30");
		}
	}
}


loop statements:
`````````````````
Loops in Java is a feature used to execute a particular part of the program repeatedly if a given condition evaluates to be true.


   -for loop
   -while loop 
   -do while loop
   
for loop:
`````````
purpose:

this for loop is used to iterate a part of the program several/multiple times.

when should you use for loop?

if the number of iteration is fixed, it is recommended to use
for loop.

 -simple for loop
 -nested for loop
 -for each or enhanced for loop
 -labelled for loop

 simple for loop:
 ````````````````
 we can initilize the variable,
 check the condition ,
 increment/decrement the value 
 
 it consitsts of four parts
 
 1.initialization -it is an optional condition 
 
 2.condition 
 
 3.increment/decrement
 
 4.statement
 
syntax:

 for(initialization;condition;increment/decrement)
 {
  //statement 
 }
 
example:
```````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
      int i=1;
       for(i=1;i<=10;i++)
       {
    	   System.out.println(i);
       }
	    
	}
}

//program to displaying first 10 numbers in reverse order?

example:
`````````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
      int i=10;
       for(;i>=1;i--)
       {
    	   System.out.println(i);
       }
	    
	}
}


display even numbers from 1 to 10 using for loop and if statement?

2

4

6

8

10

example:
``````````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
		
		  for(int i=1;i<=10;i++) { 
			  if(i%2==0)
			  {
				 System.out.println(i); 
			  }
		  
		  }
		 
	   // % operator is giving you reminder
	   
	   
	}
}

assignment:
```````````
display odd numbers from 1 to 10 using for loop and if statement?


example:
````````
//program for displaying first 10 numbers using for loop
public class Test1 {

   public static void main(String[] args) 
	{
		
		  for(int i=1;i<=10;i++) { 
			  if(i%2!=0)
			  {
				 System.out.println(i); 
			  }
		  
		  }
		 
	   // % operator is giving you reminder
	   
	   
	}
}


nested for loop:
````````````````
defining for loop inside another for loop. 


if we have a for loop inside another for loop, it is known as 
nested for loop.

The inner for loop executes completely whenever outer for loop 
executes.

once control comes from outerfor loop to inner for loop, it executes inner for loop until the condition became false, once condition false 
again it goes back to outerfor loop then comes to inner loop like this 
flow is going on.



example:
````````
//program on nested for loop
public class Test2 {

	public static void main(String[] args) {

		// loop of i

		for (int i = 1; i <= 3; i++) {
			// loop of j
			for (int j = 1; j <= 3; j++) {
				System.out.println(i + " " + j);
			}
		}

        
	}
}

/*output:
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3*/



output:
````````
*
* *
* * *
* * * *
* * * * *

example:
`````````

public class Test3 {

	public static void main(String[] args) {
		
		//define the outer for loop
		
		//outer for loop
		for(int i=1;i<=5;i++)
		{
			//inner for loop
			
			for(int j=1;j<=i;j++)
			{
				System.out.print("*");
			}
			
			System.out.println();
			
		}
	}
}

output:
```````
*
* *
* * * 
* * * *
* * * * * 






output:
````````
* * * * * *
* * * * *
* * * *
* * * 
* * 
*
   do this program as an assignment?
   
   











for each loop or enhanced for loop:
````````````````````````````````````

this enhanced for loop introduced from java 1.5 version onwards.

purpose:
``````````
it provides an alternative approach to traverse the array or collection in java.


it is mainly used to traverse the array or collection elements.

how the values will be stored inside an array variable?
  
  based on the index 
  
  array index starts from 0th location .
  
  
 int a[]={100,200,300};
 
  sysout(a[0]);
  sysout(a[1]);
  
  
note:
if the array length is 'n' 
maximum index is 'n-1'
because array index starts from 0 th location

  

syntax of foreach loop:
````````````````````````
it consists of datatype with the varaible followed by a colon (:) , then array or collection varaible.

  for(datatype variable:actualvaraible)
  {
  
     //body of for each loop
  }


int a[]={10,20,30,40,50};


  for(int b:a)
  {
    System.out.println(b);
  }

example:
`````````
class Test4
{
	
	public static void main(String[] args) {
		
		int a[]= {10,20,30,40,50};
		
		System.out.println(a[0]);
		System.out.println(a[1]);
		System.out.println(a[2]);
		System.out.println(a[3]);
		System.out.println(a[4]);
		
		System.out.println("=======using for loop displaying array elements============");
		
		for(int i=0;i<a.length;i++)
		{
			System.out.println(a[i]);
		}
		
		System.out.println("======using for each loop displaying array elements===");
		
		for(int b:a)
		{
			System.out.println(b);
		}
		
	}
}


//using for each loop calculate total of array elements
  int a[] ={1,2,3,4};
  
answer:
```````

public class Test5 {
	
	public static void main(String[] args) {
		
		int a[]= {1,2,3,4};
		int sum=0;
		for(int b:a)
		{
			sum=sum+b;
		}
		
		System.out.println("sum of array elements is : " + sum);
	}

}

 
 

java labelled for loop:
```````````````````````
we can have a name of each java for loop.
To do so, we used label before the for loop.
it is useful while using the nested for loop as we can break/continue
specific for loop.

syntax:

  labelname:
  
   for(intialization;condition;increment/decrement)
   {
     //code to be executed
    }
	
example:
`````````
//program on nested for loop
public class Test2 {

	public static void main(String[] args) {

		// using label for outer for loop
	aa:
		for (int i = 1; i <= 3; i++) {
			// using label for inner forloop of j
			
	bb:
			for (int j = 1; j <= 3; j++) {
				
				if(i==2&&j==2) {
					break aa;
				}
				System.out.println(i + " " +j);
			}
		}

	}
}

/*output:
1 1
1 2
1 3
2 1
*/



  

java while loop:
`````````````````
the java while loop is used to iterate a part of the program 
repeatedly until the specified condition is true.

as soon as the condition becomes false, the loop automatically stops.

the while loop is considered as a repeating if statement. 
if the number of iternation is not fixed, it is recommended to use the  while loop.


syntax:
```````    
   //intialize the value;
    while(condition)
	{
	  //code to be executed;
	  increment/decrement ;
	}

write one java program displaying 1 to 10 numbers using while loop?

example:
````````

public class Test6 {
	
	public static void main(String[] args) {
		
		//initialization 
		int i=1;
		//while loop
		
		while(i<=10)
		{
			System.out.println(i);
			i++;
		}
	}

}

do this program to display the 1 to 10 numbers in reverse order?


public class Test6 {
	
	public static void main(String[] args) {
		
		//initialization 
		int i=10;
		//while loop
		
		while(i>=1)
		{
			System.out.println(i);
			i--;
		}
	}

}


do while loop:
``````````````
do while loop is used to iterate a part of the program repeatedly,until the specified condition is true.

if the number of iteration is not fixed and you must have to execute
the loop at least once, it is recommended to use a do-while loop.

do while loop is called an exit control loop.

java do while loop is executed at least once because condition is 
checked after loop body.


syntax:
```````
  do{
  
    //code to be executed/loop body
	//update staetment
  
  } while(condition);
  
  
example:
````````

public class Test7 {
	
	public static void main(String[] args) {
		
		int i=1;
		do {
			System.out.println(i);
			i++;
			
		} while (i>=10);
		
	}

}

for loop v/s while loop v/s do-while loop:
``````````````````````````````````````````

 if the no.of iteration is  fixed, then it is recommended to use 
  for loop 
  
 if the no.of iteration is not fixed, then it is recommended to use
 while loop 
 
  if the no.of iteration is not fixed and you must execute the statement atleast once then we should use do while loop.
  
  
jump statements:
````````````````
Jump statements are one of the types of control statements in Java that directs the flow of execution in a program.


 break 
 continue
 
break statement:
````````````````
it is encountered inside a loop, 
the loop is immediately terminated and the program control resumes at the next statement following the loop.


break statement is used to break loop or switch statement.


it breaks the current flow of the program at specified condition.

in case of inner loop, it breaks only inner loop.


we can use java break statement in all types of loops such as

 -for loop,
 -while loop 
 -do while loop
 
 syntax:
 
      jump-statement;
	  break;
	  
	  
example:
````````

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=10;i++)
		{
			if(i==5) {
				//breaking the loop
				break;
			}
			System.out.println(i);
		}
		
	
	}

}


 break statement with inner loop:
 
 it breaks inner loop only if you use break statement inside 
 the inner loop.
 
 
example:
`````````

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=3;i++)
		{
			//inner loop
			for(int j=1;j<=3;j++)
			{
				if(i==2&&j==2)
				{
					break;
				}
				System.out.println(i + " " +j);
			}
			
		}
		
	
	}

}



3 assignments:

use break statement inside labelled for loop?

use break statement inside while loop?

use break statement inside do-while loop?


continue statement:
````````````````````
it is used in loop control structure when you need to jump 
to the next iteration of the loop immediately.

it can be used with all types of loops such as for,while and dowhile 



purpose: it is used to continue the loop.

note:

it continues the current flow of the program and skips the remaining 
code at the specified condition .


   for(int i=1;i<=10;i++)
   { 
      if(i==5){
	  continue;
	  }
	  sysout(i)
   }
1
2
3
4
6
7
8
9
10

in case of an inner loop, it continues the inner loop only.


syntax:

     jump-statement;
	 continue;
	 
example:
````````
`
public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=10;i++)
		{
			if(i==5)
			{
				continue;
			}
			System.out.println(i);
			
		}
		
	
	}

}

example of continue statement with inner for loop:
`````````````````````````````````````````````````````

public class Test8 {
	
	public static void main(String[] args) {
		
		
		//using for loop
		for(int i=1;i<=3;i++)
		{
			//inner loop
			for(int j=1;j<=3;j++)
			{
				if(i==2&&j==2) {
					continue;
				}
				System.out.println(i + " " + j);
			}
			
		}
		
	
	}

}

assignment:
```````````
use continue statement in labelled for loop?
use continue statement in while loop?
use continue staetment in do while loop?


type casting in java:
`````````````````````
in java, type casting is a method or process 
that converts a datatype into another datatype.
in both ways 

 -manually 
 -automatically
 
 the automatic conversion is done by the java compiler 
 manual conversion is done by the programmer .
 
 
 there are two types of type castings 
 
   1.widening type casting / implicit type conversion 
   2.narrowing type casting  / explicit type conversion 
   
   
1.widening type casting:

converting a lower data type into a higher datatype is called
widening type casting.

it is also known as implicit conversion.

it is done automatically by the java compiler.

it is safe because there is no chance to lose the data. 


widening type casting:
``````````````````````````
byte -> short -> int -> long -> float -> double 

example:
`````````

public class Test9 {
	
	public static void main(String[] args) {
		
		int x=7;
		//automatically converts the integer type into long type
		long y = x;
		
		//automatically converts the long type into float type
		float z = y;
		
		System.out.println("before conversion , int value " + x);
		System.out.println("after conversion, long value: " + y);
		System.out.println("after conversion, float value: " +z);
		
		
	}

}



narrowing type casting:
```````````````````````````

note:
in case of narrowing type casting, we might get a chance to lose the data in the explicit conversion .


double->float->long->int->short->byte

converting a higher data type into a lower data type is called 
narrowing type casting.

it is also called as explicit conversion 

it is done manually by the programmer.

if we do not perform casting then the compiler gives you compile time 
error.




   
example:
``````

public class Test9 {
	
	public static void main(String[] args) {
		
		double d= 234.5656;
		
		//converting double datatype into long data type
		long l =(long)d;
		
		//converting long datatype into int datatype
		
		int i = (int)l;
		
		System.out.println("before conversion , double value " + d);
		System.out.println("after conversion, long value: " + l);
		System.out.println("after conversion, int value: " +i);
		
		
	}

}



package:
````````
package is a collection of 

 -classe(s)
 -interface(s)
 -&sub package(s) 
 
 
note:
it is highly recommended to keep either classes/interfaces anything 
inside the package only .

why? what is the reason?

advantages of package(s)?

1.reusability
2.to avoid naming conflicts


types of package(s):

  in java, we have two types of packages are available 
  
   1.pre-defined pacakage(s)-sunmicrosystem 
   
       pre-defined classes/interfaces 
	   
	   
   2.user-defined package(s)-developed by programmers
   
       user defined classe/interfaces
	   
	   
   
as part of core java/jse, we have some predefined packages 
are available in java.


list of predefined core java/jse packages:
`````````````````````````````````````````````

all the core java pacakges starts with java.

all the advanced java packages starts with javax.


java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.zip

official webstite:
````````````````
https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Integer.html
 
   
user defined packages:
``````````````````````
developed by java programmers just to keep their own classes or 
interfaces

syntax to define the package:
`````````````````````````````

  package <pacakagename>;
  
how can we import the package:

syntax:
  import <packagename>.<classname>/<interfacename>;
  
  import <packagename>.*;
  
  * represents everything inside the pacakge.
  
note:
package statement must be the first executable statement in java otherwise it will give you compile time error.

Test1.java:
```````````
package com.techm.jse.packages;

public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y) );
	}

}

Test2.java:
``````````
package com.infy.jse.packages;

import com.techm.jse.packages.Test1;

//execution logic class
public class Test2 {
	
	public static void main(String[] args) {
	
		Test1 obj = new Test1();
		//ctrl+shift+o -> to organize imports
		
		obj.sum(2, 3);
	}

}

note:
````
package name always must be in lower case letters only.

naming convention to give user defined package name:
`````````````````````````````````````````````````````
<reverse of company website url>.<projectname>.<modulename>

example:

 com.wipro.banking.withdrawl;
 com.infosys.ecommerce.addcart;
 ....
 
note:
package statement must be always first executable statement 
otherwise it gives you compile time error.


note:
`````
in different ways we can import:

short cut key to import the package in eclipse is 

 ctrl + shift + o 
 



avoiding naming conflicts:

we can define multiple classes with the same name by differentiating 
with package names.



Test1.java:
````````````
package p1;

public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}

Test1.java:
````````````
package p2;

public class Test1 {
	
	public void sub(int x, int y)
	{
		System.out.println(x-y);
	}

}


Test2.java:
```````````
package p3;
//import p1.Test1;


//execution logic class
public class Test2 {
	
	public static void main(String[] args) {
		
		p1.Test1 obj = new p1.Test1();
		obj.sum(2, 3);
		
		//object creation using fully qualified naming approach
	    p2.Test1 obj1 = new p2.Test1();
	    obj1.sub(4, 3);
		
		
		
	}

}




subpackage:
```````````

  note:
  
  by importing main package, only we are able to access 
  main package belonging classes, interfaces but we can't access
  sub package belonging properties.
  
  if you want sub package belonging classes,interfaces we have to
  import sub pacakge explicitly.
  
  
Test1.java:
````````````
package p1;

public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}

Test2.java:
```````````
package p1.p2;

public class Test2 {

	 public void sub(int x, int y)
	 {
		 System.out.println("substraction is : " +(x-y));
	 }
}

Test3.java:
````````````
package p3;

import p1.Test1;
import p1.p2.Test2;

//execution logic class
public class Test3 {
	
	public static void main(String[] args) {
		
		//create the object for Test1
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
		
		Test2 obj1 = new Test2();
		
		obj1.sub(4, 3);
		
	}

}

 access modifiers:
 `````````````````
 
 we have 4 access modifiers in java
 
  1.private
  2.default
  3.protected
  4.public
  
purpose:
```````
it controls the visibility of the data 
over the packages.


private access modifier:
`````````````````````````

private properties 

we can access only with in the class in which class you defined. 

we can't access from other classes of same pacakge
we can't access from other package other classes .

Test1.java:
````````````
package p1;

public class Test1 {
	
	//private property
	private void sum(int x, int y)
	{
		System.out.println(x+y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}

Test2.java:
```````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		//error: obj.sum(2,3);
	}

}


default access modifier:
````````````````````````
  default is not a keyword like other 
  access modifiers.
  
  if we are not using any access modifier keyword
  it will consider as default property.
  
within the package from any class, we are able to access 
default properties.

shall we try in other package?

from other packages, we are not able to access default properties.

if we try for that, we will get compile time error saying that 
property not visible.

protected access modifier:
```````````````````````````
with in the class -> yes
with in the same package -> yes

other package indepenedent class -> no

other package child class -> yes

Test1.java:
``````````
package p1;

public class Test1 {
	
	//protected property
	protected void sum(int x, int y)
	{
		System.out.println(x+y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}

Test2.java:
````````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2,3);
	}

}

Test3.java:
````````````
package p2;

import p1.Test1;
//other package child class
public class Test3 extends Test1 {
	
	public static void main(String[] args) {
		
		Test3 obj = new Test3();
		obj.sum(3, 2);
		
	}

}

public:
````````
there is no restriction for this access modifier
if you define anything as public access modifier 
we can access from anywhere. 

 ->universal access modifier.
 
 
 with in the class -> yes
 with in the same package - yes
 
 other pacakge indepenedent class ->yes
 other package sub class -> yes
 
Test1.java:
```````````
package p1;

public class Test1 {
	
	//public property
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}

Test2.java:
````````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2,3);
	}

}

Test3.java:
```````````
package p2;

import p1.Test1;
//other package independent class
public class Test3  {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 2);
		
	}

}



note:

if the method is not available inside child class, then immediately 
java compiler will look for that particular method inside parent class.


Object class is acting as super class in java for every class 
whether it is predefined or userdefined class.

what are the different methods we have inside Object class?

   clone()
   finalize()
   hashCode()
   equals()
   toString()
   getClass()
   wait()(3)
   notify()
   notifyAll()
 

every class in java, is an example of what type of inheritance?

 single/simple inheritance

class Test1 
{
}
 
note:
if you are just displaying any java class object internally it invokes
toString() accordingly we will get the output.


example:
````````
package com.infotech.object;
//example on Object class few methods
public class Test1 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		Test1 obj1 = new Test1();
		
		
		
		//toString()-returns string reprsentation of the Object
		System.out.println(obj.toString());//com.infotech.object.Test1@515f550a
		//ctrl+shift+t
		
		System.out.println(obj);
		
		System.out.println(obj.hashCode());
		System.out.println(obj1.hashCode());
		
		System.out.println(obj.getClass());
		
        System.out.println(obj.equals(obj1));
		
		
		
	}

}

overriding toString() method to get the desired result:

Student.java:
``````````````
package com.infotech.object;

public class Student {

	
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	@Override
	public String toString()
	{
		return stid + " " +stname;
		
	}
	
}

Test2.java:
```````````
package com.infotech.object;

public class Test2 {
	
	public static void main(String[] args) {
		
		Student obj1 = new Student();
		obj1.setStid(100);
		obj1.setStname("khan");
		
		System.out.println(obj1);
		
	}

}


exception handling:
```````````````````
if you make any mistakes in java syntactically , what will happen?

 then java compiler gives error, those errors are what we call 
 compile time errors.
 
 
while we are running / executing the java program, jvm is giving us
some errors those errors are called runtime errors. 
technical name of runtime error is known as exception.

why are we getting the exceptions?

because of logical mistakes.
 
  division of two numbers 
  
    100/20 if you pass valid input - valid output
	
	 100/0 -> error (logical mistake) ->


if you pass any invalid input -> jvm won't process 
->error -> exceptions



when we get the exception what will happen?


->control terminated abnormally

->jvm will give system error messages



 1000 lines 
--
--
-- int x = 100/0;
--
--
--
--
 997 lines of code won't executed
 
java.lang.ArithmeticException 

we have to avoid the above drawbacks for this what we have to 
do as a programmer?


  we need to handle the exceptions.
  
  
how can we handle the exceptions?

 in java, we have 5 java reserved keywords are there
 
  1.try
  2.catch
  3.finally
  
  4.throws
  5.throw


try:
````
try block is used to keep the problematic statements which are causes 
problems at runtime.


syntax:
```````
  try{
     //problematic statement(s)
  }

catch:
`````
catch block is  used to catch the exception and to provide user friendly 
message.


atm machine 
 account =5k 
  withdraw - 6k
  
insufficient funds


syntax:


               catch(exceptionclassnaem <referencevariablename>)
			   {
			     //user friendly message
			   }



whenever we get the exception, control terminated abnormally that's why 
we can't maintain normla flow of the execution, 
to maintain we have to handle the exceptions

java is robust(strong), meaning that in every case means postive case 
or negative case our project should be in a postition to give the support
to the end users otehrwise no one will use our product.

example of exception handling using try and catch along with 
Scanner class:
``````````````````````````````````````````````````````````````
package com.infotech.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter the first number");
		
		int fno = s.nextInt();
		System.out.println("enter the second number");
		int sno = s.nextInt();
		
		int division = fno/sno;
		
		System.out.println("division is : " + division);
		}
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		catch(InputMismatchException im)
		{
			System.out.println("please pass only numeric values");
		}
	
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		
	}

}

finally block:
``````````````
finally block is used to keep closing releated logic like 
closing the file, closign the database connection etc.. 

if you keep that closing related logic, in both valid and invalid case 
the code gets executed . 

so that data leakage issues won't occure if you keep closing related 
logic inside finally block.

note:
while we are handling the exceptions the order must be from 
specific to general not from general to specific because if you mention 
like that code will be unreachable by the java compiler getting compile time error.

example:
````````
package com.infotech.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter the first number");
		
		int fno = s.nextInt();
		System.out.println("enter the second number");
		int sno = s.nextInt();
		
		int division = fno/sno;
		
		System.out.println("division is : " + division);
		}
		catch(ArithmeticException ae)
		{
			System.out.println();
		}
		catch(RuntimeException re)
		{
			System.out.println(re);
		}
		
		
		//RuntimeException re = new ArithmeticExceptioni();
		
		
		finally
		{
			System.out.println("finally block executed always");
		}
	
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		System.out.println("rest of the statements");
		
	}

}


throws:
```````
throws is a java reserved keyword 

purpose: it will give you the instruction or warning to calling function 
to keep the called function under try and catch block.


example:
````````
package com.infotech.exceptions;

//called program
public class Test2 {
	
	//called function
	public void division() throws ArithmeticException
	{
		int z = 100/0;
		System.out.println("division is: " + z);
	}

}

Test3.java:
````````````
package com.infotech.exceptions;
//calling program
public class Test3 {
	
	//calling function 
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("please check division method logic");
		}
		
		System.out.println("rest of the statements executed");
		
	}

}

throw:
```````

using throw keyword, we can throw an exception explictly.


  100/0 
  
     ArithmeticException -> jvm->implicitly

based on our condition, if the condition met, if we want to throw 
any exception explictly then we have to use throw keyword.

syntax:

    throw new <exceptionclassname>();

using throw keyword, we can implmenet our own exceptions 
or customized exception.


   ->ecommerce application 

   ->checking the product based on the product weight

   ->if product weight is < 100 it is valid else < 100 
     throw the InvalidProductException .

note:
every exception in java is a class whether it is predefined exception or 
user defined exception.

	 
	 
	 

Test4.java:
``````````
package com.infotech.exceptions;
//business logic class
public class Test4 {
	
	public void checkProduct(int weight)
	{
		if(weight > 100)
		{
			System.out.println("product is valid");
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ip)
			{
				System.out.println("product weight must be greater than 100");
			}
			
		}
	}

}

InvalidProductException.java:
```````````````````````````````
package com.infotech.exceptions;

//it is an user defined exception class
public class InvalidProductException extends Exception {

}


Test5.java:
```````````
package com.infotech.exceptions;

//execution logic class
public class Test5 {

	
	public static void main(String[] args) {
		
		
		Test4 obj = new Test4();
		
		obj.checkProduct(20);
		
	}
}






FileHandling/iostreams:
```````````````````````

stream : flow of the data in between primary memory to secondary memory 
and viceversa.



  while we are working on top of files, make sure we have to import 
  one predefined package i.e java.io 
  
  
  why files ->to store the data
  
  how can we create the file in java?
  
  using one predefined class File 
  
  
default imported package to every java program is
java.lang 

otherthan this package, if we want to use any other classes/interfaecs
make sure we have to import corresponding package 

example to create the file using File class of java.io package:
````````````````````````````````````````````````````````````````
package com.infotech.files;
import java.io.File;
import java.io.IOException;
public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the file using File class
		
		File f = new File("abc.txt");
		try {
		f.createNewFile();
		}
		catch(IOException io)
		{
			System.out.println(io);
		}
		
		System.out.println(f.exists());
		
	}

}








On top of files, we can perform different operations 

 1.read operation 
 
 2.write operation 
 
 stream ->  it is a flow of data in between primary memory to secondary memory or viceversa.
 
 write opeation: 
 
   meaning that we are trying to insert the data into file.
   
 read operation: 
 
   meaning that we are trying to read the data from the file.
   

in iostreams, we have two types of streams 
are available in java.
 
  1.byte stream 
  2.character stream 
  
 if the data flow in the form byte by byte - bytestream 
 if the data flow in the form of character by character - character stream 

in java, io package we have different classes which belongs to 
byte stream, character stream 


read() -read the data from the file 

 where exactly file is available-inside our hard disk/secondary memory
 
 primary memory 
 
 from secondary memory to primary memory.
 
write() -> data flow is happening from primary memory to secondary memory.

when should we use bytestream related classes?

If we have a file that contains binary data, then it will be appropriate to use Byte stream.

when should we use character stream related clases?

Character stream is useful when we want to process text files







 
character stream related classes:
`````````````````````````````````

   java.io package 
   
   write operation 
   
   while we are peforming write operation data flow is happening 
   from primary memory to secondary memory.
   
   
FileWriter
BufferedWriter
PrintWriter

  -majorly we are using three classes which are of character stream type 
  classes for the purpose of writing the data into the file.
  
  
  
FileWriter:
````````````
FileWriter is a character stream related class, which is used to write 
the character data into the file.

example:
````````
package com.infotech.files;

import java.io.FileWriter;
import java.io.IOException;

public class Test2 {
	
	public static void main(String[] args) throws IOException {
		//write operation 
		//create the object of FileWriter 
		FileWriter fw = new FileWriter("abc.txt");
		
		//write the data
		
		
		
		fw.write("abc\n");
		
		fw.write("rama\n");
		
		fw.write(100);
		
		fw.flush();
		
		
		
		System.out.println("write operation successfully done");
		
		
		
	}

}

drawbacks:
``````````
1.using this we can't insert the different types of data, even though if we try it gets converted into corresponding unicode character.

2./n we have to use for the line separator and it may or may not work in all operating systems because it got implemented in c language.

that's why we will go from FileWriter to BufferedWriter


BufferedWriter:
```````````````
whiel we are creating the object of BufferedWriter , we have to pass the 
object of Writer class implemenation class object. 

 BufferedWriter bw = new BufferedWriter(Writer w);

example:
````````
package com.infotech.files;

import java.io.BufferedWriter;
import java.io.FileWriter;

public class Test3 {
	
	public static void main(String[] args) throws Exception {
		
		//create the object of FileWriter
		
		FileWriter fw = new FileWriter("abc.txt");
		//create the object of BufferedWriter
		
		BufferedWriter bw =
				new BufferedWriter(fw);
		
		bw.write("abc");
		bw.newLine();
		bw.write("rama");
		bw.newLine();
		bw.write(100);
		
		bw.flush();
		
		System.out.println("write opearation done");
	}

}


drawaback:
we can't write differnt types of data but we can achieve the line separator problme by using a new method newLine() of BufferedWriter class.
which will work in any operating systems because it got implemented in java language.

to avoid the above problem, we have to move from BufferedWriter class 
to PrintWriter class.


PrintWriter:
``````````````
PrintWriter is the class available in java.io package for the purpose 
of writing the character data very effectively.

example:
````````
package com.infotech.files;

import java.io.IOException;
import java.io.PrintWriter;

public class Test4 {
	
	public static void main(String[] args)throws IOException{
		
		
		//create the object of PrintWriter class
		
		PrintWriter pw = new PrintWriter("abc.txt");
		
		pw.println("abc");
		pw.println("Rama");
		pw.println(100);
		pw.println(3.4f);
		pw.println(false);
		pw.print(56.78);
		
		pw.flush();
		
		System.out.println("write operation has done");
		
		
	}

}






read operation:
``````````````
  we are reading the data from the file 
  data flow is happening from secondary memory to primary memory.
  
  
FileReader

   read() 
   
   
example on FileReader:
```````````````````````
package com.infotech.files;

import java.io.FileReader;

public class Test5 {
	
	public static void main(String[] args) throws Exception {
		
		//create the object of FileReader
		
		FileReader fr = new FileReader("abc.txt");
		
		int x = fr.read();	
		
		while(x!=-1)
		{
			System.out.print((char)x);
			x= fr.read();
		}
	}

}

In FileReader, since we have only read(), 
using this we can read the data character by character because of this 
in between secondary memory to primary memory huge network traffic or 
to and fro calls gets increased, so it may be  become the cause of 
performance degradataion 

that's why we have to move from FileReader class to next level character stream related class i.e BufferedReader

if we use BufferedReader, we can perform the read operation line by line 
instead of character by character .


   
BufferedReader:
````````````````

example:
`````````
package com.infotech.files;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Reader;

public class Test6 {
	
	public static void main(String[] args) throws Exception{
		
		
		//create the Reader class implementation class object
		
		Reader r = new FileReader("abc.txt");
		
		//create the object for BufferedReader class
		
		BufferedReader br = new BufferedReader(r);
		
		
		String s = br.readLine();
		
		while(s!=null)
		{
			System.out.println(s);
			s=br.readLine();
		}
		
	}

}







 
bytestream related classes:
```````````````````````````

   to read or write the binary data.
   
   
FileInputStream 

   -read operation 
   
FileOutputStream 

   -write operation 
   
  
example on read and write operation on binary data using bytestream 
related clasess:
``````````````````````````````````````````````````````````````````````

package com.infotech.files;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Test7 {
	
	public static void main(String[] args) {
		try {
			//create the object for FileInputStream for reading the binary data
		FileInputStream fis = new FileInputStream("encapsulation.jpg");
		
		//create the object for FileOutputStream for writing the binary data
		FileOutputStream fos = new FileOutputStream("naveesh.jpg");
		
		
		int x;
		while((x=fis.read())!=-1) {
			
			fos.write(x);
		}
		System.out.println("image created succesfully");
		}
		
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
	}

}


serialization & desererialization 
``````````````````````````````````
serialziation:
``````````````

the process of writing the object data  into network suppored format 
is known as serialization.

because by default network won't support object format data to transfer 
from one machine to another machine.

desserialization:
````````````````

the process of reading the object data from the network supported file 
is known as deserizliation.



   

 ->ObjectInputStream 
     predefined class 
	 java.io 
	 purpose: to read the object data 
	 method: readObject()
	 
 ->ObjectOuputStream 
     predefined class
	 java.io
	 purpose: to write the object data 
	 
	 method: writeObject()
	 
 

Student.java:
```````````````
package com.infotech.files;

import java.io.Serializable;

public class Student implements Serializable{
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student(int stid, String stname)
	{
		this.stid=stid;
		this.stname=stname;
		}
	
	public Student()
	{
		
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}

}

example for serialziation:
`````````````````````````````
package com.infotech.files;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;

//serialization
public class Test8 {
	
	public static void main(String[] args) throws Exception{
		
		
		//create the object for FileOutputStream 
		FileOutputStream fos = new FileOutputStream("ram.txt");
		
		//create the object for ObjectOutputStream 
		
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		
		
		Student st= new Student(100,"ram");
		
		
		oos.writeObject(st);
		
		System.out.println("serialization process has done");
		
		
	}

}

example for desererialization:
`````````````````````````````
package com.infotech.files;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

//deserialization
public class Test9 {

	
	public static void main(String[] args) throws Exception {
		
		//create the object of FileInputStream 
		
		FileInputStream fis = new FileInputStream("ram.txt");
		//create the object of ObjectInputStream 
		
		ObjectInputStream ois = new ObjectInputStream(fis);
		
		
		Object obj = ois.readObject();
		//convert Object type to Student type
		//convert parent type to child type -down casting
		
		
		
		Student stu = (Student)obj;
		
		System.out.println(stu);
		
	
	}
}

 
 
note:
every java class we can't serialize, to make it happen corresponding 
java class must be implementing from Serializable marker interface 
which is available in java.io package otherwise we will get exception 
saying that java.io.NotSerialziable 

 
transient keyword:
```````````````````
transient is a variables modifier used in serialization. At the time of serialization, if we don't want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type
 
 
 
 
 
 
 
 
 
Collection framework:
`````````````````````
collection framework :
````````````````````

int x = 100;
int y = 200;
int z = 300;


 ->1000 values 
 1000 variables 
 
 to store 1000 values declaring 1000 varialbles, 
 is not a good programming practice.
 
 
Array:
  
   using arrays, we can store multiple values in a single variable.
   
   int x[]={100,200,300};
   
   
   int x[] =new Integer[5];
   
 -> the size is fixed in nature, you can't increase or decrease the memory 
    at runtime.
	
 -> using arrays, we can store only homogenious data, we can't store 
    heterogenous data.
	
 -> inside arrays, we don't have any ready made methods,to perform any 
    operation, we have to do manually.

 -> internally arrays are not following standard data structures.

 collection framework:
 ````````````````````
 it is the standardized mechanism of grouping similar type of data 
 and differnt type of data into a single entity. 
 
  ->java.util package
  
 

 
 few interfaces and few implementation clases

                 1 Collection 
   
2.List          3.Queue                 4.Set

                                        5.SortedSet
          
                            


interface SortedSet extends Set extends Collection 
{
}




 

Collection:
```````````

if we want to group similar objects and diffrent objects as a single entity 
then we should go for Collection .

note:
Collection is the root interface for all the remaining interface(s)
there is no direct implementation class for this Collection interface.


add()-to add an object

addAll(Collection)

remove()
removeAll()


List:
`````

  always working based on index
  
List is the predefined interface avaialble in java.util package

-> it allows both homogenious and heterogenous object(s)
-> insertion order is preserved
-> duplicates are allowed
-> null insertion is possible 

note:
 collection supports only object data.
 
 
 For List interface, sunmicrosyste people provided few implemenation classes
 
 1.ArrayList
 2.LinkedList
 3.Vector
 4.Stack
 
 
 List l = new ArrayList();
 

example:
``````````
package com.jse.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {

	public static void main(String[] args) {
		
		//create the object for List
		
		List l = new ArrayList();
		
		//add the object
		l.add(Integer.valueOf(100));
		l.add(Integer.valueOf(200));
		l.add(new String("rama"));
		l.add(Boolean.valueOf(true));
		l.add(Integer.valueOf(100));
		l.add(null);
		
		System.out.println(l);//[100, 200, rama, true, 100, null]
		 		
		
		l.add(300);
		System.out.println(l);//[100, 200, rama, true, 100, null, 300]
		
		l.add(1, Integer.valueOf(300));
		
		System.out.println(l);//[100, 300, 200, rama, true, 100, null, 300]
	
		System.out.println(l.remove(1));
		
		System.out.println(l);//[100, 200, rama, true, 100, null, 300]
		
		l.remove(Integer.valueOf(100));
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		System.out.println("size of the collection : " + l.size());
		
		System.out.println(l.get(1));//rama
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		List l1 = new ArrayList();
		l1.add(500);
		l1.add(400);
		l1.add(600);
		
		l.addAll(l1);
		
		System.out.println(l);//[200, rama, true, 100, null, 300, 500, 400, 600]
		
		l.removeAll(l1);
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		
		System.out.println(l.contains(200));
		
		System.out.println(l.isEmpty());
		
		l.clear();
		System.out.println(l.isEmpty());
		
		System.out.println(l);//[]
		
		
	}
}

ArrayList hierarchy:
``````````````````````
class ArrayList implements List extends Collection 
{
}




assignment:
do the same program w.r.to LinkedList


Collection 
List
   ArrayList
   LinkedList
   Stack
   Vector
   
   
  


  
day-21:
```````
eventhough we are passing primitive data internally it is getting converted into object format.

autoboxing and autounboxing
`````````````````````````````

Autoboxing is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. 

For example, converting an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this is called unboxing.

java compiler:

autoboxing: primitive type to object type
autounboxing: object type to primitive type

this feature is available from jdk 1.5 version onwards.



difference between ArrayList and LinkedList:

ArrayList internally follows dynamic array algorithm to store the elements 
and if our frequent operation is accessing / retrieval then it is highly 
recommended to use this ArrayList.

   ArrayList implements RandomAccess
   {
   }


LinkedList internally follows doubly linkedlist algorithm where the data 
is getting stored based on the node wise. 
that's why if our frequent operation is insertion/deletion/updation we can 
go for LinkedList because no shift operations are happend like ArrayList.



Stack
Vector 
do the programs on top of above two classes?







Queue:
```````

Queue is also sub interface of Collection 

->if we want to represent a group of individual objects prior to processing then we should go for Queue and Queue follow First In First Out algorithm.



  
  

  Queue
  
   -ArrayDeque
   -LinkedList
   -PriorityQueue
   
   
boolean offer(Object obj)
Object poll()
Objet remove()
Object peek()-will give you head element->null
Object element()-will give you head element ->exception 

...

in case of ArrayDeque and LinkedList 

  -it allows both homogenious and heterogenous data
  -duplicates are allowed
  -insertion order is preserved
  -null insertion is possible only if implementation class is LinkedList
   in case of ArrayDeque it gives you NullPointerException

in case of PriorityQueue 

  -it allows only homogenious data
  -insertion order is not preserved
  -duplicates are allowed
  -null insertion is not possible if you try for that it gives you 
   NullPointerException 
   
   

example:
````````
package com.jse.cfw;

import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.Queue;

public class Test4 {
	
	public static void main(String[] args) {
		
		Queue obj = new LinkedList();
		
		obj.offer("rama");
		obj.offer("freejava");
		obj.offer("benny");
		obj.offer("shekhar");
		obj.offer("shekhar");
		obj.offer(null);
		
		
		
		
		
		
		System.out.println(obj);
		
		System.out.println(obj.poll());
		
		
		System.out.println("head: " +obj.element());
		
		System.out.println("head:" + obj.peek());
		
		obj.clear();
		
		//System.out.println(obj.element());//NoSuchElementException
		
	    System.out.println(obj.peek());
		
	}

}



day-22:
````````

Set extends Collection 

SortedSet extends Set extends Collection 


Set:
````

Set is the predefined interface available in java.util package


 ->it supports both homogenious and heterogenous data
 ->duplicates are not allowed 
 ->insertion order is not preserved.
 ->null insertion is possible but only for one time.
 
   Set obj = new Set();//invalid
   

->HashSet
->LinkedHashSet


insertion order is preserved in case of LinkedHashSet but it is not 
in the case of HashSet.

example:
```````
package com.jse.cfw;

import java.util.LinkedHashSet;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		
		
		Set s = new LinkedHashSet();
		
		s.add("abc");
		s.add(null);
		s.add(123);
		s.add(true);
		s.add(123);
		
		System.out.println(s);
	}

}



if you knew in advance only my collection class allows only particular type 
of data then i can create the collection object by specifying that data type.



using generics concept we are getting two advantages

1.compile time errors we will get rather than runtime errors and these compile time errrors are far better than runtime errors.

2.we no need to perform type casting when you apply generics concept.

  

example:
``````````
package com.jse.cfw;

import java.util.LinkedHashSet;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		
		//generics concept
		Set<Integer> s = new LinkedHashSet();
		
	    for(int i=1;i<=10;i++)
	    {
	    	s.add(i);
	    	
	    }
		
	    
	    
		//for each loop
		
		for(Integer o:s) {
			
			
			if(o%2==0)
			{
				System.out.println(o);
			}
			
		}
	}

}


how to add user defined object to any colelction class:
````````````````````````````````````````````````````````
package com.jse.cfw;

import java.util.ArrayList;

public class Test2 {
	
	public static void main(String[] args) {
		
		ArrayList<Student> al = new ArrayList();
		
		
		al.add(new Student(100,"Rama"));
		al.add(new Student(101,"pavan"));
		al.add(new Student(102,"praveen"));
	
		
	     //foreach loop
		for(Student s:al)
		{
			if(s.getStname().startsWith("p"))
			{
				System.out.println(s);
			}
				
		}
		
	}

}




SortedSet:
`````````

->it supports only homogenious data.

->duplicates are not allowed

->the order we can predict (it will sort the data )
  natural sorting technique -> alphabetical order, ascending 
  

->null insertion is not possible (NullPointerException)


SortedSet is the sub interface of Set interface , it is the sub interface 
of Collection 


SortedSet is maintaining some specific new methods 


  first()
  last()
  headSet()
  tailSet()
  subSet()
  
  


for this SortedSet interface 

   ->TreeSet
   
   
 package com.jse.cfw;

import java.util.TreeSet;

public class Test6 {

	public static void main(String[] args) {

		TreeSet<Integer> s = new TreeSet();

		s.add(123);
		s.add(876);
		s.add(98);
		s.add(67);
		s.add(1000);

		/*
		 * s.add("rama"); s.add("praveen"); s.add("harish"); s.add("john");
		 */

		System.out.println(s);
		
		System.out.println(s.first());
		System.out.println(s.last());
		System.out.println(s.headSet(123));
		System.out.println(s.tailSet(123));
		System.out.println(s.subSet(98, 1000));
	}

}
  




day-23:
````````

how to add user defined objects to the TreeSet:
```````````````````````````````````````````````
package com.jse.cfw;

public class Student implements Comparable<Student> {

	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		this.stid = stid;
		this.stname = stname;

	}

	public String toString() {
		return stid + " " + stname;
	}



	

	@Override
	public int compareTo(Student o) {
		
		if(stid>o.getStid())
		{
			return -1;
		}
		else if(stid<o.getStid())
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}



	
}



Test6.java:
````````````
package com.jse.cfw;

import java.util.TreeSet;

public class Test6 {

	public static void main(String[] args) {

		TreeSet<Student> s = new TreeSet();

		Student st1 = new Student(10,"chenna");
		Student st2 = new Student(8,"venkat");
		
		s.add(st1);
		s.add(st2);
		
		System.out.println(s);
		
	}

}

note:
To add any object to TreeSet it should be homogenious and Comparable objects
otherwise we will get java.lang.ClassCastException.

example on overriding equals() and hashCode():
```````````````````````````````````````````````

Student.java:
``````````````
package com.jse.cfw;

public class Student  {

	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		this.stid = stid;
		this.stname = stname;

	}

	public String toString() {
		return stid + " " + stname;
	}


	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + stid;
		result = prime * result + ((stname == null) ? 0 : stname.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (stid != other.stid)
			return false;
		if (stname == null) {
			if (other.stname != null)
				return false;
		} else if (!stname.equals(other.stname))
			return false;
		return true;
	}
	
	
}

Test6.java:
`````````
package com.jse.cfw;

import java.util.HashSet;

public class Test6 {

	public static void main(String[] args) {

		HashSet<Student> s = new HashSet();

		Student st1 = new Student(10,"chenna");
		Student st2 = new Student(10,"chenna");
		
		s.add(st1);
		s.add(st2);
		
		System.out.println(s);
		
	}

}


day-24:
````````

cursors in java
`````````````````
cursor -> it is pointing to some element 


  Enumeration-outdated 
  
     on top of legacy classes 
	  
	   Hashtable
	   Vecotr
	   Stack...
	   
	   
  Iterator
  ListIterator
  
  

example on Iterator:
```````````````````
package com.jse.cfw;

import java.util.HashSet;
import java.util.Iterator;

public class Test7 {
	
	public static void main(String[] args) {
		
		HashSet<Integer> hs = new HashSet<Integer>();
		
		for(int i=1;i<=10;i++)
		{
			hs.add(i);
			
		}
		System.out.println(hs);
		
		//foreach method
		
		/*
		 * for(Integer i: hs) { System.out.println(i); }
		 */
		
		Iterator<Integer> iterator = hs.iterator();
		
		while(iterator.hasNext())
		{
			System.out.println(iterator.next());
		}
		
		iterator.remove();
		System.out.println("=====================");
		for(Integer i:hs)
		{
			System.out.println(i);
		}
		
		
		
		
	}

}
//hasNext() - to check whether collection object contains elements or not?
//next() -> to read the current element
//remove() -> to remove the elements



note: Iterator is uni directonal cursor
using this we are allowed to retrieve the elements only in forward 
direction.

universal cursor.



ListIterator:
``````````````
ListIterator is the powerfull cursor in entire cfw.

 -> we are allowed to retreive the elements in both forward direction 
    and as well as backward direction.

 ->using this we can modify,add, remove the data.
	
	
drawback: we can apply this ListIterator interface only on top of list related implemenataion classes. 
 
 
example on ListIterator:
```````````````````````
package com.jse.cfw;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.ListIterator;

public class Test7 {

	public static void main(String[] args) {

		ArrayList<Integer> al = new ArrayList<Integer>();

		for (int i = 1; i <= 10; i++) {
			al.add(i);

		}

		System.out.println(al);
		
		ListIterator<Integer> ltr = al.listIterator();
		System.out.println("retrieveing the elements in forward direction");
		while(ltr.hasNext())
		{
			System.out.println(ltr.next());
		}
		
		ltr.add(11);
		
		System.out.println("retreiving the elements in backward direction");
		while(ltr.hasPrevious())
		{
			System.out.println(ltr.previous());
		}
		
		ltr.set(100);
		
		System.out.println(al);

	}

}
//hasNext() - to check whether collection object contains elements or not?
//next() -> to read the current element
//remove() -> to remove the elements
//hasPrevious()-to check whether previous elements are there or not?
//previous()- to retrieve the previous element


example on Enumeration interface:
``````````````````````````````````
package com.jse.cfw;

import java.util.Enumeration;
import java.util.ListIterator;
import java.util.Vector;

public class Test7 {

	public static void main(String[] args) {

		Vector<Integer> v = new Vector<Integer>();

		for (int i = 1; i <= 10; i++) {
			v.addElement(i);

		}

		Enumeration<Integer> enr = v.elements();
		
		while(enr.hasMoreElements())
		{
			System.out.println(enr.nextElement());
		}
		
	}

}
//hasNext() - to check whether collection object contains elements or not?
//next() -> to read the current element
//remove() -> to remove the elements
//hasPrevious()-to check whether previous elements are there or not?
//previous()- to retrieve the previous element



day-25:
```````
Comparable:
``````````
   Comparable is meant for default sorting order
       
	     numbers -> ascending 
		 string -> alphabetical order
		 
		 
  all wrapper classes and String class are Comparable objects
  
  java.lang package 
  
  
     int compareTo()
	 
	 > -> +value
	 < -> -value
	 = -> 0
	 
	 
Comparable:
```````````
Student.java:
``````````````
package com.jse.cfw;

public class Student implements Comparable<Student> {

	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		this.stid = stid;
		this.stname = stname;

	}

	public String toString() {
		return stid + " " + stname;
	}


	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + stid;
		result = prime * result + ((stname == null) ? 0 : stname.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (stid != other.stid)
			return false;
		if (stname == null) {
			if (other.stname != null)
				return false;
		} else if (!stname.equals(other.stname))
			return false;
		return true;
	}

	@Override
	public int compareTo(Student o) {
		
		if(this.stid>o.getStid()) {
			return -9;
		}
		else if(this.stid<o.getStid())
		{
			return +9;
		}
		else
		{
			return 0;
		}
	}


	
	
}


Test8.java:
```````````
package com.jse.cfw;

import java.util.TreeSet;

public class Test8 {
	
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet();
		
		ts.add(new Student(1000,"Rama"));
		ts.add(new Student(101,"john"));
		
		
		
		System.out.println(ts);
	}

}


Student.java:
````````````
package com.jse.cfw;

public class Student implements Comparable<Student> {

	private int stid;
	private String stname;

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getStname() {
		return stname;
	}

	public void setStname(String stname) {
		this.stname = stname;
	}

	public Student() {

	}

	public Student(int stid, String stname) {
		this.stid = stid;
		this.stname = stname;

	}

	public String toString() {
		return stid + " " + stname;
	}


	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + stid;
		result = prime * result + ((stname == null) ? 0 : stname.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (stid != other.stid)
			return false;
		if (stname == null) {
			if (other.stname != null)
				return false;
		} else if (!stname.equals(other.stname))
			return false;
		return true;
	}

	@Override
	public int compareTo(Student o) {
		
		return -stname.compareTo(o.getStname());
		
	}
	
}

Comparator:
``````````
Comparator interface available inside java.util pacakge

 inside this interface we do have one method
 
   compare(T1,T2);
   
	 
Comparator is meant for getting the data in our own order / custom order









day-26:
````````

(key,value) pair

Map

   -
SortedMap


A Map doesn't allow duplicate keys, but you can have duplicate values.

A Map can't be traversed

keySet()
entrySet()


HashMap: HashMap is the implementation class of Map, but it doesn't maintain 
         any order.
		 
LinkedHashMap: it is also the implemenataion class of Map, it inherits HashMap class. it maintains insertion order.


TreeMap:
 TreeMap is the implementation class of SortedMap, it maintains ascending order
 
  put() -> insert any entry in to the map 
   
   entry ->(key,value)
   
   
  putAll(Map m) -> it is used to insert the specicied map into the existing map.
  
  

Map.Entry:
``````````
Entry is the inner interface of Map. so we will be accessed it by Map.Entry name.

it returns a collection view of the map.


   getKey() 
   getValue()
   

example on HashMap:
```````````````````
1.HashMap doesn't allow duplicate key objects but it allows duplicate value objects
2.it allows null values for both key objects and as well as value objects.
3.insertion order is not preserved.

example:
````````
package com.jse.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		Map m = new HashMap();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		m.put(null, null);
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		Set set =m.entrySet();
		
		Iterator itr = set.iterator();
		
		while(itr.hasNext())
		{
			Map.Entry entry = (Map.Entry)itr.next();
			System.out.println(entry.getKey() + " " + entry.getValue());
					
					
		}
		
	}

}

with generics syntax :
``````````````````````
package com.jse.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		Map<Integer,String> m = new HashMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		m.put(null, null);
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		Set<Entry<Integer, String>> set = m.entrySet();
		
		Iterator<Entry<Integer, String>> itr = set.iterator();
		
		while(itr.hasNext())
		{
	
	       Entry<Integer, String> entry = itr.next();
			System.out.println(entry.getKey() + " " + entry.getValue());
					
					
		}
		
	}

}


using for each loop traversing map elements:
````````````````````````````````````````````
package com.jse.cfw;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		Map<Integer,String> m = new HashMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		m.put(null, null);
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		for(Map.Entry<Integer,String> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	}

}

LinkedHashMap vs HashMap

all the properties of HashMap are applicable to LinkedHashMap except LinkedHashMap follows insertion order.


SortedMap:
``````````
SortedMap is the sub interface of Map interface 

 TreeMap is the implementtaion class
 
 
1.TreeMap doesn't allows null keys or null values if you try to add we will get
  runtime exception saying that java.lang.NullPointerException
  
2.duplicate keys are not possible where as duplicate values are possible

3.we will get the data in ascending order based on the key objects.

example on top of TreeMap:
``````````````````````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Integer,String> m = new TreeMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		for(Map.Entry<Integer,String> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	}

}


example:
````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Integer,String> m = new TreeMap<Integer,String>();
		
		//adding elements to Map
		
		m.put(100, "rama");
		m.put(200, "amith");
		m.put(45, "john");
		m.put(67, "leshvi");
		
		m.put(67, "charvi");
		m.put(101, "rama");
		
		
		for(Map.Entry<Integer,String> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
		System.out.println("===========================");
		
		System.out.println(m.firstKey());
		System.out.println(m.lastKey());
		System.out.println(m.headMap(100));//{45=john, 67=charvi}
		System.out.println(m.tailMap(100));//{100=rama, 101=rama, 200=amith}
		System.out.println(m.subMap(45, 101));//{45=john, 67=charvi, 100=rama}
		
		
	}

}


adding user defined object as a value object to the TreeMap:
```````````````````````````````````````````````````````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Integer,Book> m = new TreeMap<Integer,Book>();
		
		//create Book Object
		
		Book b1 = new Book(1,"java");
		Book b2 = new Book(2,"angular");
		Book b3 = new Book(3,"spring");
		
		//adding elements to Map
		
		
		
		m.put(400,b1);
		m.put(101, b2);
		m.put(300, b3);
		
		
		for(Map.Entry<Integer,Book> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	
	}

}



sorting the data in our customized order:
``````````````````````````````````````````
package com.jse.cfw;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class Test9 {
	
	public static void main(String[] args) {
		
		
		SortedMap<Book,Integer> m = new TreeMap<Book,Integer>(new BookNameComparator());
		
		//create Book Object
		
		Book b1 = new Book(1,"java");
		Book b2 = new Book(2,"angular");
		Book b3 = new Book(3,"spring");
		
		//adding elements to Map
	
		m.put(b1,400);
		m.put(b2,101);
		m.put(b3,300);
		
		for(Map.Entry<Book,Integer> m1: m.entrySet())	
		{
			System.out.println(m1.getKey() + " " + m1.getValue());
		}
		
	
	}

}


note:
````
this sorting happens based on the key object only not based on the value object
that is the reason your user defined object also must be the key object.

MyCompartor.java:
`````````````````
package com.jse.cfw;

import java.util.Comparator;

public class MyComparator implements Comparator<Integer> {

	@Override
	public int compare(Integer o1, Integer  o2) {
		
		return -o1.compareTo(o2);
	}

}

BookNameComparator.java:
````````````````````````
package com.jse.cfw;

import java.util.Comparator;

public class BookNameComparator implements Comparator<Book> {

	@Override
	public int compare(Book o1, Book o2) {
		return -o1.getBookName().compareTo(o2.getBookName());
	}

}

Book.java:
```````````
package com.jse.cfw;

public class Book {
	
	private int bookId;
	private String bookName;
	public int getBookId() {
		return bookId;
	}
	public void setBookId(int bookId) {
		this.bookId = bookId;
	}
	public String getBookName() {
		return bookName;
	}
	public void setBookName(String bookName) {
		this.bookName = bookName;
	}
	public Book(int bookId, String bookName) {
		super();
		this.bookId = bookId;
		this.bookName = bookName;
	}
	
	public Book()
	{
		
	}
	@Override
	public String toString() {
		return bookId + " " + bookName;
	}
	
	

}


assignment:
````````````
refer about Hashtable and do one program


  
   

 












  
  









